s17day20

内容回顾：
	1. Http请求相关
	
	2. Django请求生命周期
		alert({{name}});
	3. Model操作
		单表：
			[obj,obj,obj] = models.xxx.objects.all()
			
			[{},{},{}] = models.xxx.objects.values('id','name'....)
			
			[(),()] = models.xxx.objects.values_list('id','name'....)
			
		一对多：
			dep部门表: 标题    (user_set)
			
			user员工表：用户  邮箱  部门Id(FK)
			
			
			qs = [obj,obj,obj] = models.user.objects.all()
			for row in qs:
				row.id,row.name,row.email,row.xx.title
				
			[{},{},{}] = models.xxx.objects.values('id','name','xx__title')
			[(),(),()] = models.xxx.objects.values_list('id','name','xx__title')
			
		多对多：
			业务线: id   title    M2M
			
			
			管理员: id   name     (bs_set)
			
			
			业务线和管理员关系表
			
			obj = models.bs.objects.get(id=1)
			
			[管理员,管理员,管理员] = obj.m2m.all()
			
	4. 分页 
	
	5. csrf
		
		
	6. cookie
		保存在浏览器客户端的键值对
		
	7. session
		以来cookie，保存在服务器端的键值对
		
		
今日内容：
	1. FBV & CBV
		a. 
			FBV -> 函数
			CBV -> 类
					- dispatch
					- get获取/post提交
					
		b. 应用：登录验证
			
			继承：
				  单继承：
						# class BaseView(View):
						#     def dispatch(self, request, *args, **kwargs):
						#         if request.session.get('username'):
						#             response = super(BaseView,self).dispatch(request, *args, **kwargs)
						#             return response
						#         else:
						#             return redirect('/login.html')
						#
						# class IndexView(BaseView):
						#
						#     def get(self,request,*args,**kwargs):
						#         return HttpResponse(request.session['username'])
						  
				  
				  多继承：
			
						# 多继承方式：
						# class BaseView(object):
						#     def dispatch(self, request, *args, **kwargs):
						#         if request.session.get('username'):
						#             response = super(BaseView,self).dispatch(request, *args, **kwargs)
						#             return response
						#         else:
						#             return redirect('/login.html')
						#
						# class IndexView(BaseView,View):
						#
						#     def get(self,request,*args,**kwargs):
						#         return HttpResponse(request.session['username'])
		
			装饰器：
				
				def auth(func):
					def inner(request,*args,**kwargs):
						if request.session.get('username'):
							obj = func(request,*args,**kwargs)
							return obj
						else:
							return redirect('/login.html')
					return inner

				
				# @method_decorator(auth,name='get')
				class IndexView(View):
					
					@method_decorator(auth)
					def dispatch(self, request, *args, **kwargs):
						if request.session.get('username'):
							response = super(IndexView,self).dispatch(request, *args, **kwargs)
							return response
						else:
							return redirect('/login.html')

					@method_decorator(auth)
					def get(self,request,*args,**kwargs):
						return HttpResponse(request.session['username'])
						
					@method_decorator(csrf_exempt)  # 无效
					def post(self,request,*args,**kwargs):
						return HttpResponse(request.session['username'])

				
				特殊：CSRF
					class IndexView(View):
					
						@method_decorator(csrf_exempt)
						def dispatch(self, request, *args, **kwargs):
							return super(LoginView,self).dispatch(request, *args, **kwargs)

				
						def get(self,request,*args,**kwargs):
							return HttpResponse(request.session['username'])
							
						
						def post(self,request,*args,**kwargs):
							return HttpResponse(request.session['username'])
	2. 序列化
		方式一：
			user_list = models.UserInfo.objects.all()
			data = serializers.serialize("json", user_list)
			[
				{"model": "app01.userinfo", "pk": 1, "fields": {"username": "\u5174\u666e", "password": "123123"}}, 
				{"model": "app01.userinfo", "pk": 2, "fields": {"username": "\u94f6\u79cb\u826f", "password": "666"}}
			]
			
		方式二：
			
			user_list = models.UserInfo.objects.values('id','username')
			user_list = list(user_list)
			data = json.dumps(user_list)
			[
				{"username": "\u5174\u666e", "id": 1}, 
				{"username": "\u94f6\u79cb\u826f", "id": 2}
			]
			
			问题：对json.dumps做定制：
				
					import json
					from datetime import date
					from datetime import datetime

					class JsonCustomEncoder(json.JSONEncoder):
						def default(self, field):
							if isinstance(field, datetime):
								return field.strftime('%Y-%m-%d %H:%M:%S')
							elif isinstance(field, date):
								return field.strftime('%Y-%m-%d')
							else:
								return json.JSONEncoder.default(self, field)


					user_list = [
						{'id':1,'name':'alex','ctime': datetime.now()},
						{'id':2,'name':'eric','ctime': datetime.now()}
					]

					data = json.dumps(user_list,cls=JsonCustomEncoder)
					print(data)
					
					
		总结：
			- 模板渲染
			- Ajax
				- json序列化
				- 前端：js添加到页面
		
		
	3. Form表单验证（用户请求验证+生成HTML标签）
		示例：用户管理
			a. 添加用户页面
				- 显示HTML标签
				- 提交：数据验证
				- 成功之后保存
				- 错误显示错误信息
		
		总结：
			1. 创建Form类（本质就是正则表达式的集合）
				
				from django.forms import Form
				from django.forms import fields
				from django.forms import widgets

				class UserForm(Form):
					username = fields.CharField(
						required=True,
						error_messages={'required':'用户名不能为空'},
						widget=widgets.TextInput(attrs={'class':'form-control'})
					)
					password = fields.CharField(
						required=True,
						error_messages={'required': '邮箱不能为空','invalid':'邮箱格式错误'},
						widget = widgets.TextInput(attrs={'class': 'form-control'})
					)
					# fields.EmailField()
					# fields.GenericIPAddressField(protocol='ipv4')

					ut_id = fields.ChoiceField(
						choices=[],
						widget=widgets.Select(attrs={'class':'form-control'})
					)

					role_id = fields.MultipleChoiceField(
						choices=[],
						widget=widgets.SelectMultiple(attrs={'class':'form-control'})
					)

					def __init__(self,*args,**kwargs):
						super(UserForm,self).__init__(*args,**kwargs)
						# self.fields已经有所有拷贝的字段
						self.fields['ut_id'].choices = models.UserType.objects.values_list('id','title')
						self.fields['role_id'].choices = models.Role.objects.values_list('id','caption')

			2. 只是生成HTML标签: 添加页面
				form = MyForm()
				
				{{form.xx}}
				
			3. 带默认值的HTML标签： 编辑页面
				form = MyForm(initial={'xx': xxx})
				
				{{form.xx}}
				
			4. 提交数据
				form = MyForm(data=request.POST)
				
				if form.is_valid():
					print(form.cleaned_data)
				else:
					print(form.errors)
					
			问题：下拉框数据无法实时更新
				class UserForm(Form):
					username = fields.CharField(
						required=True,
						error_messages={'required':'用户名不能为空'}
					)
					password = fields.CharField(
						required=True,
						error_messages={'required': '邮箱不能为空','invalid':'邮箱格式错误'}
					)

					ut_id = fields.ChoiceField(choices=[])

					def __init__(self,*args,**kwargs):
						super(UserForm,self).__init__(*args,**kwargs)

						self.fields['ut_id'].choices = models.UserType.objects.values_list('id','title')
								
					
			
		示例：只用表单验证的功能（Ajax提交），注册&登录
		
		
		定律：
			【个数少，内容少】  
			页面摸态对话框：添加+删除+编辑 =》 ajax（无刷新） + Djaogo Form组件
																		- 验证
																		- 生成HTML（可用可不用，因为提交页面不刷新）
											     
			
			
			【适用于：数据个数多；博客】
			     新URL方式：添加+删除+编辑 =》 Form标签提交（页面刷新） + + Djaogo Form组件
				
																			- 验证
																			- 生成HTML（不用，无保留上次输入的内容）
		
			
			个人：
			
				- 删除利用模态对话框，确认
				- 添加+修改： 新URL方式
		



作业：主机管理
		
	用户表(id, user,pwd,email,mm)
	业务线(id, name) # 用户表_set
	主机表(id host ip port FK(业务线))
	用户业务线关系表(id  uid  bid)   ******
	
	
	1. 登录+注册（Ajax+form组价）
	2. FBV&CBV
		业务线管理（列表，增加，修改） # 删除对话框确认删除
		主机管理（列表，增加，修改） # 删除对话框确认删除
		用户管理（列表，增加，修改） # 删除对话框确认删除
	3. 分页
	4. BootStrap【可选】

	如何做：
		周一 + 周二： 课上讲的内容理解
		
		周三       ： 写作业
		
		周六：        本周不太理解+以前不理解；下午预习
	4. 缓存
	
	5. 中间件
	
	6. 信号
	
	7. Admin
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			